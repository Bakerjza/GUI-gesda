# GUI遍历算法和遍历模型构建
-- Activity是一个应用程序组件，通常它提供一个用户可以交互完成某项任务的屏幕。Activity中所有操作都与用户密切相关，是一个负责与用户交互的组件。在一个Android应用程序中，一个Activity通常就是一个单独的屏幕，它上面可以显示一些控件也可以监听用户事件并作出响应。一个应用程序通常包含多个Activity，Activity之间的交互可以完成相应的应用程序功能，从这点上讲，Activity之间是一种有向图的关系，GUI之间也是如此。

-- 应用程序GUI探测策略是该自动化遍历方法的核心。当获取到当前GUI控件树后，以怎样的遍历算法和逻辑执行任务决定遍历方法GUI覆盖率的高低。本文方法的GUI遍历过程基于Nilsson[9]提出的一个著名的图搜索过程，它是一个表达能力很强的搜索策略框架。为了尽可能多地遍历到应用程序包含的GUI，在本文方法中没有目标节点也就是没有目标GUI。由于GUI上能够触发GUI转换的控件是事先未知的，所以OPEN表只存放当前要模拟执行用户行为的GUI节点，通过动态换进换出OPEN表内的GUI节点实现深度优先的搜索策略。CLOSE表用于存放已经扩展到的GUI节点，避免发生循环。

-- 算法描述了GUI遍历算法，在事先不知道应用程序Activity和GUI转换信息的前提下能够按照深度优先的策略探测应用程序GUI。算法以已启动的目标应用程序作为输入, 首先初始化GUI列表和任务列表(1)~3))，然后探测应用程序启动后的首个GUI添加到GUI列表, 并把该GUI上的控件树作为一个任务添加到任务列表，启动该任务(4)~9))。遍历引擎从当前任务中选择一个控件交付用户行为模拟模块进行用户行为模拟(12)~13))，用户行为模拟结束后暂停当前任务并设置当前GUI状态(14)~15))，随后遍历引擎根据该状态继续执行：如果当前任务已完成, 则返回父GUI, 继续执行父GUI任务(18)~19))；如果发生GUI转换并产生新的GUI节点, 则创建新的GUI任务, 并建立当前GUI与新GUI之间的父子关系(22)~23))，添加新GUI和其任务到各自相应的列表后执行新任务(24)~27))；如果GUI转换到已拓展的非父GUI节点, 则模拟点击返回键避免循环遍历, 否则返回父GUI(29)~30))，继续执行任务32)。应用程序GUI不停的转换与任务的轮替执行一一对应，遍历引擎不断地从执行状态的任务中选出一个控件交付用户行为模拟模块进行用户行为模拟直到所有任务结束，即任务列表为空或满足终止条件时结束。
用户与应用程序交互的动作主要包括按键动作和触摸动作两类。一般而言，手机按键包括返回键、HOME、音量键和电源键等按键，在这里把应用软键盘也归类为按键键盘。每一个物理按键和软键盘按键都有一个KEYCODE值，例如返回键KEYCODE_BACK值为4。可以通过KEYCODE来执行按键操作，比较简单。
触摸动作模拟屏幕上的点击、长按、拖动等动作，这些动作需要依据动作所施于的控件对象在屏幕上的区域来模拟具体的动作行为。由上述可知，每个控件都有自己在屏幕上的矩形区域，只需要把与控件相应的模拟动作限定在控件所属矩形区域内即可完成行为动作模拟。
此外，针对输入和点击行为，可以依据获取的控件属性信息、上下文环境信息如数据类型等进行启发式输入和点击操作，而不是随机输入无意义的字符和点击按钮。

# 功能模块
-- 预处理模块通过反编译目标应用程序APK文件，解析其中的AndroidManifest.xml文件获得目标应用的包名和所有Activity名等信息，并在Android模拟器上启动目标应用程序。 GUI获取模块自动化地获取应用程序当前GUI并表示为可扩展标记语言(Extensible Markup Language，XML)文件。若发生GUI转换则暂停正在执行的GUI任务，根据GUI转换的结果重启暂停状态的GUI任务或提取当前GUI上的控件信息如控件的层次结构、各控件属性等建立新的GUI任务；否则继续执行当前GUI任务。 遍历引擎模块负责获取当前要执行的GUI任务并依照遍历模型，以近似于程序执行的逻辑产生待模拟用户界面(User Interface，UI)控件交付用户行为模拟模块模拟相应的用户行为。 用户行为模拟模块接收遍历引擎交付的UI控件，模拟该控件相应的用户行为包括简单动作和复杂动作。
小部件提取:页面上的小部件随后提取。活动和对话框是包含具有不同功能的各种小部件的页面，例如Button和CheckBox。可以在相应的基于xml的布局文件中定义它们，也可以通过定制语句将它们动态地添加到页面中。在我们的方法中，我们使用至少一个事件处理程序保留小部件，因为它们的响应逻辑是动态探索的主要目标。然后，我们利用从事件开始的提取方法。一方面，在布局文件中注册的小部件的事件被标识为实例检索配置，比如android：onClick="onClick"。可以获得小部件的资源id、类型和文本，并找到事件的回调方法。另一方面，使用侦听器注册方法指定的事件(例如，setOnClickListener)通过扫描代码来识别。我们进一步对方法的调用者采用数据流分析来定位其声明语句，这是在布局中指定小部件时的findViewById调用，或者是在动态创建小部件时的新的实例化方法。在这种情况下，将获得小部件的资源id(如果指定了资源id)，并从布局文件或方法调用的参数中检索其类型和文本。
菜单通常由层次化的菜单项组成，每个菜单项都被视为具有相应事件处理程序的小部件。定义菜单界面有静态和动态两种方式。前者是在资源文件中指定菜单的组成部分，然后将资源加载到程序中。后者使用与菜单相关的方法(例如，addSubMenu, add)来构造菜单结构。与其他类型的小部件不同，深层菜单项是通过选择它们的祖先菜单来显示的。因此，在识别分层菜单项的过程中，我们还需要记录每个菜单项的显示路径，其中包含了要选择的祖先菜单的顺序。
3)过渡分析:不同页面之间的过渡通常由小部件的回调调用的方法来标识。它意味着在回调中定位预先指定的方法，并分析方法调用的参数以确定目标页面。确定方法后，将在不同页面之间创建一个转换。否则，如果没有标识这样的方法，我们将从源页面创建一个指向自身的转换。然后，我们根据指定的方法解释规则。

构成Android应用程序GUI的各种UI元素(统称为控件)间天生所具有的层次和嵌套关系，与XML文档中元素之间的关系十分相似，使用XML文件来描述图形用户界面是十分自然和有效的方法。Android提供了一个简单的词汇表，用来对应View类和子类，比如一些按钮和文本编辑框等。一个Activity的用户界面是由一组按层派生的视图类View的视图对象组成。每个视图占据Activity窗口的特定矩形区域监听并响应用户的交互。例如，一个视图可能是一个按钮，当用户点击它时启动一个点击按钮操作。视图是控件的基类，视图组是可以包含其他视图的特殊视图，是用于UI布局和容器的基本类。Android应用程序GUI上的控件树是通过视图和视图组组合形成的每个GUI对应一棵控件树，每棵控件树代表一个任务。遍历引擎依据遍历模型和遍历算法操作处理每棵控件树生成待模拟控件交付用户行为模拟模块模拟用户行为如点击、输入、滑动屏幕等。在很多情况下，控件或内容太多会超出容器或整个屏幕，这些超出容器或屏幕的控件或内容不但不会显示在屏幕上，而且不能与显示的内容一起被获取，是无法预知的。这些被隐藏的控件能否被获取是GUI自动化遍历方法要解决的一个关键问题。另外，对话框和菜单作为一个独立的窗口弹出时它们会获得屏幕焦点，它们与普通GUI有同样的页面结构，但是不同的是它们不能作为一个父GUI被子GUI返回，跳出即关闭。自动化遍历GUI的过程中需要自动识别并处理这类GUI。2.1.1节和2.1.2节分别阐述了本文解决这两类问题的方法。
gesdastatic负责提取dPTM，gesdadynamic执行动态探索。.从一个安卓安装包（apk）静态地构造一个依赖集成页面转换模型（dPTM）。该模型使用页面为基本单位来描述它们之间的转换。将依赖项捕获为表示页面中具有回调的小部件的元素、状态影响回调的小部件、页面的生命周期回调，分别对应上面的三个依赖项。利用静态模型引导基于深度优先遍历的动态探索。在页面探索时，具有回调和生命周期回调的小部件会优先执行，而回调受其他窗口小部件状态影响的小部件则完全基于这些状态的组合执行。

# 结果输出分析
--遍历过程中访问到的GUI越多意味着更高的GUI覆盖率，换句话说就是能够访问到更多的应用程序的功能或行为，这对基于程序运行时行为特征的Android应用程序动态安全分析具有重要的意义。但是，一般情况下应用程序包含的GUI数目难以统计，因此不能通过GUI数目给出方法的定量评估标准[1-5]。文献[6, 8]实验中选取的应用程序过于简单，最复杂的应用程序仅包含6个Activity[6]或8个GUI[8]，虽然它们有较高的GUI覆盖率(56%~92%[6]，66.7%~100%[8])但是其结果不具有代表性。尽管大部分情况下应用程序的Activity数量和GUI数量不相等，但是依然能够通过Activity的覆盖率近似地对方法的有效性进行定量的评估[7]。文献[7]基于深度优先的GUI探测方法的平均Activity覆盖率为59.39%，该文献的一项调查报告显示人工方式遍历(7位用户操作应用程序的结合)应用程序的Activity平均覆盖率为30.8%。本文方法对三个应用程序Activity的覆盖率分别为60.7%、77.8%和56.4%，Activity平均覆盖率约为65%，高于文献[7]中自动化方法的59.39%和人工方式的30.8%。分析实验结果可知覆盖率的高低与应用程序的复杂度有一定的关系，应用程序包含的Activity越多意味着应用的功能越多、设计越复杂，这会增加遍历的难度从而影响Activity遍历覆盖率。
--对应用程序本身和遍历过程的分析表明，限制Activity覆盖率进一步提高的原因主要包括以下几个方面：对于一些自定义布局和控件等不能精确模拟相应的用户行为，从而影响遍历结果；应用程序对用户身份的限制会对遍历路径产生不同引导，一部分界面或Activity无法遍历到；此外还有一些第三方登录等类似用户行为无法进行模拟。